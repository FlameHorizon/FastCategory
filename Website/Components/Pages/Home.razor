@page "/"
@rendermode InteractiveServer

@using FastPayment.Core
@using System.Runtime.CompilerServices
@using System.Runtime.InteropServices
@using Website.Models
@using MudBlazor.Extensions
@using System.ComponentModel.DataAnnotations

@inject IJSRuntime JSRuntime

<PageTitle>Home</PageTitle>

<MudItem xs="12" sm="6" md="6">
  <MudPaper Class="pa-4">
    <EditForm Model="@_model" OnValidSubmit="OnValidSubmit">
      <DataAnnotationsValidator/>

      <MudDatePicker 
        Label="Date" 
        @bind-Date="_model.Date" 
        For="@(() => _model.Date)"
        @onkeydown="OnKeyDownDate"
        DateFormat="yyyy-MM-dd"
        ShowToolbar="false"
        autofocus/>

      <MudSelect 
        @bind-Value="_model.TransactionType" 
        Label="Transaction type" >
        @foreach (var opt in _options)
        {
          <MudSelectItem Value="opt">@opt</MudSelectItem>
        }
      </MudSelect>

      <MudAutocomplete
        @bind-Value="_model.Payee"
        Label="Reciever"
        SearchFunc="SearchRecievers">
      </MudAutocomplete>

      <MudTextField
        T="decimal"
        ValueChanged="@(v => UpdateTotalAmount(v))"
        Label="Amount" />

      @* 
        @@FIXME: When enter is pressed to select category, entire form is submitted.
        Find a way to prevent this and allow user to submit the form only when
        the "Save" button is pressed or when enter is pressed while focusing "Save" button.
      *@
      <div>
        @foreach (var category in _model.Categories)
        {
          <div class="d-flex">
            <MudAutocomplete
              @bind-Value="category.Name"
              Label="Category"
              SearchFunc="SearchCategory"
              @ref="category.Ref"/>

            <MudTextField
              @bind-Value="category.Amount"
              Immediate="true"
              Label="Split amount" />

            <MudIconButton 
              Icon="@Icons.Material.Filled.Delete" 
              Color="Color.Primary" 
              OnClick="@(() => RemoveCategory(category))" />
          </div>
        }

        <MudButton 
          Variant="Variant.Outlined" 
          Color="Color.Primary" 
          OnClick="@(() => AddCategoryAsync())">
            <MudIcon Icon="@Icons.Material.Filled.Add" />
            Split
        </MudButton>

      </div>

      <div class="d-flex flex-row-reverse">
        <MudButton 
          ButtonType="ButtonType.Submit"
          Variant="Variant.Filled"
          Color="Color.Primary"
          Class="ml-auto">
          Save
        </MudButton>
      </div>

    </EditForm>

  </MudPaper>
</MudItem>

<MudThemeProvider />
<MudPopoverProvider />

@code {
  // Model for the form.
  private readonly TransactionForm _model = new()
  {
    Categories = [new() { Name = "", Amount = 0 }]
  };

  private static Home? _instance;

  private IEnumerable<string> _options = [
    "Deposit",
    "Withdrawl",
    "Transfer"
  ];

  private string[] _searchSpace = [
    "Jedzenie:Dom",
    "Jedzenie:Miasto",
    "Jedzenie:Fast Food"
  ];

  private string[] _recievers = [
    "Biedronka",
    "Lidl",
    "Żabka",
    "Allegro",
    "Amazon",
    "MediaMarkt",
  ];

  public Home()
  {
    _instance = this;
  }

  protected async override Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      await JSRuntime.InvokeVoidAsync("JsFunctions.addKeyboardListenerEvent");
    }
  }

  private async Task<IEnumerable<string>> SearchCategory(
  string phrase,
  CancellationToken token)
  {
    if (string.IsNullOrEmpty(phrase))
    {
      return _searchSpace;
    }

    var engine = new CategorySearchEngine(_searchSpace);

    // ##TODO: Make sure search is case-insensitive.
    IEnumerable<string> result = engine.Search(phrase);
    return result;
  }

  /// <summary>
  /// Handle key presses when the date input is focused.
  /// </summary>
  /// <param name="args">Information about which key was pressed.</param>
  private void OnKeyDownDate(KeyboardEventArgs args)
  {
    if (_model.Date == null)
    {
      _model.Date = DateTime.Today;
      return;
    }

    if (args.CtrlKey)
    {
      return;
    }

    if (args.Key == "=")
    {
      _model.Date = _model.Date.Value.AddDays(1);
    }
    else if (args.Key == "-")
    {
      _model.Date = _model.Date.Value.AddDays(-1);
    }
  }

  private void OnValidSubmit()
  {
    Console.WriteLine("Form is valid");
    Console.WriteLine($"Date: {_model.Date}");
    Console.WriteLine($"Type: {_model.TransactionType}");
    Console.WriteLine($"Reciever: {_model.Payee}");
    Console.WriteLine($"Category: {_model.Categories}");
    Console.WriteLine($"Payment value: {_model.TotalAmount}");
  }

  /// <summary>
  /// Handle key presses from JavaScript.
  /// </summary>
  /// <param name="e">Information about which key was pressed.</param>
  [JSInvokable]
  public static Task JsKeyDown(KeyboardEventArgs e)
  {
    if (e.AltKey && e.Key.ToLower() == "a")
    {
      if (_instance != null)
        return _instance.InvokeAsync(() => _instance.AddCategoryAsync());
      }
    
    if (e.AltKey && e.Key.ToLower() == "s")
    {
        if (_instance != null)
            return _instance.InvokeAsync(() => _instance.OnValidSubmit());
    }

    return Task.CompletedTask;
  }

  private async Task AddCategoryAsync()
  {
    // Drop focus from any input to avoid issues with MudBlazor components.
    foreach(var cat in _model.Categories)
    {
      if (cat.Ref is not null)
      {
        await cat.Ref.CloseMenuAsync();
      }
    }

    var newCategory = new CategoryAmount();
    _model.Categories.Add(newCategory);

    if (_model.Categories.Count >= 2)
    {
      decimal sum = _model.Categories.Sum(c => c.Amount);
      decimal diff = _model.TotalAmount - sum;

      if (diff < 0)
      {
        diff = 0;
      }
      newCategory.Amount = diff;
    }

    await InvokeAsync(StateHasChanged);

    // First, render element to the DOM so that Ref is not null.
    // Then, focus the newly added category input.
    if (newCategory.Ref is null)
    {
      Console.WriteLine("Ref is null, element can't be focused.");
      await Task.CompletedTask;
    }
    else
    {
      await newCategory.Ref.FocusAsync();
    }
  }

  private void RemoveCategory(CategoryAmount category)
  {
    if (_model.Categories.Count > 1 && category != null)
    {
      _model.Categories.Remove(category);
      StateHasChanged();
    }
  }

  private async Task<IEnumerable<string>> SearchRecievers(
  string phrase,
  CancellationToken token)
  {
    if (string.IsNullOrEmpty(phrase))
    {
      return _recievers;
    }

    IEnumerable<string> result = _recievers
    .Where(x => x.StartsWith(phrase, StringComparison.OrdinalIgnoreCase));

    return result;
  }

  /// <summary>
  /// Update total amount and adjust the first category amount if there is only one category.
  /// </summary>
  /// <param name="value">New value of TotalAmount</param>
  private void UpdateTotalAmount(decimal value)
  {
    _model.TotalAmount = value;

    if (_model.Categories.Count == 1)
    {
      _model.Categories[0].Amount = value;
    }
  }
}