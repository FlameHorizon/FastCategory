@page "/"
@rendermode InteractiveServer

@using FastPayment.Core
@using Website.Models
@using MudBlazor.Extensions
@using System.ComponentModel.DataAnnotations

@inject IJSRuntime JSRuntime

<PageTitle>Home</PageTitle>

<h1>Hello, world!</h1>

<MudItem xs="12" sm="6" md="6">
  <MudPaper Class="pa-4">
    <EditForm Model="@_model" OnValidSubmit="OnValidSubmit">
      <DataAnnotationsValidator/>

      <MudDatePicker 
        Label="Date" 
        @bind-Date="_model.Date" 
        For="@(() => _model.Date)"
        @onkeydown="OnKeyDownDate"
        DateFormat="yyyy-MM-dd"
        ShowToolbar="false"
        autofocus/>

      <MudSelect 
        @bind-Value="_model.TransactionType" 
        Label="Transaction type"
        DateFormat="dd.MM.yyyy">
        @foreach (var opt in _options)
        {
          <MudSelectItem Value="opt">@opt</MudSelectItem>
        }
      </MudSelect>

      @* @@FIXME: Allow to type any text into select input. *@
      <MudSelect
        @bind-Value="_model.Payee"
        Label="Reciever">
        @foreach(var rec in _recievers)
        {
          <MudSelectItem Value="rec">@rec</MudSelectItem>
        }
      </MudSelect>

      @* ##TODO: Remove up/down arrows at the end of the input *@
      <MudTextField
        @bind-Value="_model.TotalAmount"
        Label="Payment Value" />

      @* 
        @@FIXME: When enter is pressed to select category, entire form is submitted.
        Find a way to prevent this and allow user to submit the form only when
        the "Save" button is pressed or when enter is pressed while focusing "Save" button.
      *@
      <div>
        @foreach (var category in _model.Categories)
        {
          <div class="d-flex">
            <MudAutocomplete
              @bind-Value="category.Name"
              Label="Category"
              SearchFunc="Search"/>

            <MudTextField
              @bind-Value="category.Amount"
              Label="Payment Value" />

            <MudIconButton 
              Icon="@Icons.Material.Filled.Delete" 
              Color="Color.Primary" 
              OnClick="@(() => RemoveCategory(category))" />
          </div>
        }

        <MudButton Variant="Variant.Outlined" Color="Color.Primary" OnClick="@(() => AddCategoryAsync())">
          <MudIcon Icon="@Icons.Material.Filled.Add" /> Add
        </MudButton>

      </div>

      <MudButton 
        ButtonType="ButtonType.Submit"
        Variant="Variant.Filled"
        Color="Color.Primary"
        Class="ml-auto">
        Save
      </MudButton>
    </EditForm>
  </MudPaper>
</MudItem>

<MudThemeProvider />
<MudPopoverProvider />

@code {
  // Model for the form.
  private readonly TransactionForm _model = new() {
    Categories = [new (){ Name = "", Amount = 0}]
  };

  private static Home? _instance;

  private IEnumerable<string> _options = [
    "Deposit", 
    "Withdrawl", 
    "Transfer"
  ];

  private string[] _searchSpace = [ 
    "Jedzenie:Dom", 
    "Jedzenie:Miasto",
    "Jedzenie:Fast Food"
  ];

  private string[] _recievers = [
    "Rec1",
    "Rec2"
  ];
  
  public Home()
  {
    _instance = this;
  }

  protected async override Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      await JSRuntime.InvokeVoidAsync("JsFunctions.addKeyboardListenerEvent");
    }
  }

  private async Task<IEnumerable<string?>> Search(
    string phrase, 
    CancellationToken token)
  {
    // In real life use an asynchronous function for fetching data from an api.
    await Task.Delay( 5, token);

    if (string.IsNullOrEmpty(phrase))
    {
        return _searchSpace;
    }

    var engine = new CategorySearchEngine(_searchSpace);

    // ##TODO: Make sure search is case-insensitive.
    IEnumerable<string?> result = engine.Search(phrase);
    return result;
  }

  /// <summary>
  /// Handle key presses when the date input is focused.
  /// </summary>
  /// <param name="args">Information about which key was pressed.</param>
  private void OnKeyDownDate(KeyboardEventArgs args)
  {
    if (_model.Date == null)
    {
      _model.Date = DateTime.Today;
      return;
    }

    @* 
      @@FIXME: There is a bug when user presses CTRL + = or CTRL + - to zoom in or out 
      in the browser. The date changes as well. Find a way to prevent this.
    *@

    if (args.Key == "=")
    {
      _model.Date = _model.Date.Value.AddDays(1);
    }
    else if (args.Key == "-")
    {
      _model.Date = _model.Date.Value.AddDays(-1);
    }
  }

  private void OnValidSubmit()
  {
    Console.WriteLine("Form is valid");
    Console.WriteLine($"Date: {_model.Date}");
    Console.WriteLine($"Type: {_model.TransactionType}");
    Console.WriteLine($"Reciever: {_model.Payee}");
    Console.WriteLine($"Category: {_model.Categories}");
    Console.WriteLine($"Payment value: {_model.TotalAmount}");
  }

  /// <summary>
  /// Handle key presses from JavaScript.
  /// </summary>
  /// <param name="e">Information about which key was pressed.</param>
  [JSInvokable]
  public static Task JsKeyDown(KeyboardEventArgs e)
  {
    if (e.AltKey && e.Key == "a")
    {
        Console.WriteLine("You pressed ALT + A");
        // Use InvokeAsync to ensure UI update is on the correct dispatcher
        if (_instance != null)
        {
            return _instance.InvokeAsync(() => _instance.AddCategoryAsync());
        }
    }

    return Task.CompletedTask;
  }

  private async Task AddCategoryAsync()
  {
    _model.Categories.Add(new CategoryAmount());
    await InvokeAsync(StateHasChanged);
  }

  private void RemoveCategory(CategoryAmount category)
  {
    if (_model.Categories.Count > 1 && category != null)
    {
      _model.Categories.Remove(category);
      StateHasChanged();
    }
  }
}
