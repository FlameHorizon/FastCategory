@page "/"
@rendermode InteractiveServer

@using FastPayment.Core
@using System.Runtime.CompilerServices
@using System.Runtime.InteropServices
@using System.Threading.Tasks
@using System.Globalization
@using System.Diagnostics.CodeAnalysis
@using Website.Models
@using MudBlazor.Extensions
@using System.ComponentModel.DataAnnotations

@* 
  @@BUG: There is a bug in the application which prevents adding new split categories
  or saving them using keyboard shortcuts when more than one tab open in the browser
  with the application.

  Copilot suggests that the issue might be related to the static _instance field.
  I have tried to remove the static keyword, but then the JSInvokable method can't
  access the instance.

  Personally, I don't know what might be the issue here. Have not seen this before.

  To reproduce the issue:
  1. Start the application.
  2. First tab will open automatically.
  3. Press bunch of times Alt + A to add new split categories.
  4. Open new tab with the application.
  5. In the new tab, try to add new split categories using Alt + A. It will work as well.
  6. Go back to the first tab and try to add new split categories using Alt + A.
     It will not work anymore.
*@

@inject IJSRuntime JSRuntime
@inject Microsoft.Extensions.Options.IOptions<AppSettings> AppSettingsOptions

<PageTitle>Home</PageTitle>

<div class="d-flex gap-4">
  <MudItem xs="12" sm="6" md="6">
    <MudPaper Class="pa-4">
      <EditForm Model="@_model" OnValidSubmit="OnValidSubmit">
        <DataAnnotationsValidator/>

        <MudDatePicker 
          Label="Date" 
          @bind-Date="_model.Date" 
          For="@(() => _model.Date)"
          @onkeydown="OnKeyDownDate"
          DateFormat="yyyy-MM-dd"
          ShowToolbar="false"
          autofocus/>

        <MudSelect 
          @bind-Value="_model.TransactionType" 
          Label="Transaction type" >
          @foreach (var opt in _options)
          {
            <MudSelectItem Value="opt">@opt</MudSelectItem>
          }
        </MudSelect>

        @* 
           When the user types something that is not on the list and CoerceValue is true, 
           the Value will be overwritten with the user input which allows it to be 
           passed to the validation function.
         *@

        <MudAutocomplete
          @bind-Value="_model.Payee"
          Label="Reciever"
          CoerceValue="true"
          SearchFunc="SearchRecievers">
        </MudAutocomplete>

        <MudNumericField
          T="decimal"
          Format="C"
          Culture="_culture"
          ValueChanged="@(v => UpdateTotalAmount(v))"
          Label="Amount" />

        <div>
          @foreach (var category in _model.Categories)
          {
            <div class="d-flex">
              @*
                CoerceValue is needed to allow user to enter new categories.
              *@
              <MudAutocomplete
                @bind-Value="category.Name"
                Label="Category"
                CoerceValue="true"
                SearchFunc="SearchCategory"
                @ref="category.Ref" />

              <MudNumericField
                @bind-Value="category.Amount"
                Format="C"
                Culture="_culture"
                Immediate="true"
                Label="Split amount" />

              <MudIconButton 
                Icon="@Icons.Material.Filled.Delete" 
                Color="Color.Primary" 
                OnClick="@(() => RemoveCategory(category))" />
            </div>
          }

          <MudButton 
            class="mt-2"
            Variant="Variant.Outlined" 
            Color="Color.Primary" 
            OnClick="AddCategory">
              <MudIcon Icon="@Icons.Material.Filled.Add" />
              Split
          </MudButton>

        </div>

        <div class="d-flex flex-row-reverse">
          <MudButton 
            ButtonType="ButtonType.Submit"
            Variant="Variant.Filled"
            Color="Color.Primary"
            Class="ml-auto">
            Save
          </MudButton>
        </div>
      </EditForm>

      <div class="d-flex flex-row-reverse mt-2">
          <MudButton 
            Variant="Variant.Outlined" 
            Color="Color.Primary" 
            OnClick="@(() => ExportToDisc())">
              <MudIcon Icon="@Icons.Material.Filled.Download" />
              Export
          </MudButton>
      </div>

    </MudPaper>
  </MudItem>

  <MudItem xs="12" sm="6" md="6">
    <MudPaper Class="pa-4">
      <h3>Payments</h3>
      <p>List of payments will be shown here.</p>

      @foreach(var p in _payments)
      {
        <div class="mb-2 pa-2" style="border: 1px solid lightgray; border-radius: 8px;">
          <div><b>Date:</b> @p.Date.ToString("yyyy-MM-dd")</div>
          <div><b>Type:</b> @p.TransactionType</div>
          <div><b>Payee:</b> @p.Payee</div>
          <div><b>Total Amount:</b> @p.TotalAmount.ToString("C", CultureInfo.CreateSpecificCulture("pl"))</div>
        </div>
      }
    </MudPaper>
  </MudItem>
</div>

<MudThemeProvider @ref="_mudThemeProvider" @bind-IsDarkMode="_isDarkMode"/>
<MudPopoverProvider />

<script>
  window.downloadFileFromStream = async (fileName, contentStreamReference) => {
    const arrayBuffer = await contentStreamReference.arrayBuffer();
    const blob = new Blob([arrayBuffer]);
    const url = URL.createObjectURL(blob);
    const anchorElement = document.createElement('a');
    anchorElement.href = url;
    anchorElement.download = fileName ?? '';
    anchorElement.click();
    anchorElement.remove();
    URL.revokeObjectURL(url);
  }
</script>

@code {

  // Control dark mode based on system preference.
  private bool _isDarkMode = false;
  private MudThemeProvider? _mudThemeProvider;
  
  private CultureInfo _culture = CultureInfo.CreateSpecificCulture("pl");

  // Model for the form.
  private TransactionForm _model = new()
  {
    Categories = [new() { Name = "", Amount = 0 }]
  };

  // In-memory storage for payments.
  // These payments might be used to export to a file later.
  private readonly List<Payment> _payments = new();

  private static Home? _instance;

  private IEnumerable<string> _options = [
    "Deposit",
    "Withdrawl",
    "Transfer"
  ];

  private string[] _searchSpace = [];

  private string[] _recievers = [];

  public Home()
  {
    _instance = this;
  }

  protected override void OnInitialized()
  {
    _searchSpace = AppSettingsOptions.Value.TransactionCategories.ToArray();
    _recievers = AppSettingsOptions.Value.Recievers.ToArray();
  }

  protected async override Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      _isDarkMode = await _mudThemeProvider.GetSystemPreference();
      await JSRuntime.InvokeVoidAsync("JsFunctions.addKeyboardListenerEvent");
      StateHasChanged();
    }
  }

  private async Task<IEnumerable<string>> SearchCategory(
    string phrase,
    CancellationToken token)
  {
    if (string.IsNullOrEmpty(phrase))
    {
      return _searchSpace;
    }

    var engine = new CategorySearchEngine(_searchSpace);

    IEnumerable<string> result = engine.Search(phrase, StringComparison.OrdinalIgnoreCase);
    return result;
  }

  /// <summary>
  /// Handle key presses when the date input is focused.
  /// </summary>
  /// <param name="args">Information about which key was pressed.</param>
  private void OnKeyDownDate(KeyboardEventArgs args)
  {
    if (_model.Date == null)
    {
      _model.Date = DateTime.Today;
      return;
    }

    if (args.CtrlKey)
    {
      return;
    }

    if (args.Key == "=")
    {
      _model.Date = _model.Date.Value.AddDays(1);
    }
    else if (args.Key == "-")
    {
      _model.Date = _model.Date.Value.AddDays(-1);
    }
  }

  private void OnValidSubmit()
  {
    // @@NOTE: Right now, I'm assuming the form is always valid.
    // In a real application, you would check the validation state.
    var transactionType = _model.TransactionType switch
    {
      "Deposit" => TransactionTypes.Deposit,
      "Withdrawl" => TransactionTypes.Widthdrawl,
      "Transfer" => TransactionTypes.Transfer,
      _ => TransactionTypes.Unknown
    };

    var categories = new List<Category>();
    foreach (var cat in _model.Categories)
    {
      string[] split = cat.Name.Split(":");
      string name = split.First();
      string subcategory = split.Last();
      decimal amount = cat.Amount;

      categories.Add(new Category(name, subcategory, amount));
    }

    // @@TODO: Implement following things.
    // ~ 1. Validate that sum of category amounts equals total amount.
    // 2. Validate that at least one category is provided.
    // 3. Validate that date is not null.
    // 4. Validate that transaction type is valid.
    // 5. Validate that payee is not empty.
    // 6. Show validation errors to the user.
    // + 7. Clear the form after successful submission.
    // 8. Allow users to add notes to the transaction.
    // + 9. Since all transactions will be stored in memory, implement second section where they will be displayed.

    // Convert TransactionModel to Payment entity and save to database.
    var result = new Payment
    (
      date: _model.Date!.Value,
      transactionType: transactionType,
      totalAmount: _model.TotalAmount,
      payee: _model.Payee,
      categories: categories,
      notes: ""
    );

    _payments.Add(result);

    Console.WriteLine("Form is valid");

    // To speed up adding new transactions, reuse the same date.
    _model = new TransactionForm
    {
      Categories = [new() { Name = "", Amount = 0 }]
    };

    _model.Date = result.Date;

    InvokeAsync(StateHasChanged);
  }

  /// <summary>
  /// Handle key presses from JavaScript.
  /// </summary>
  /// <param name="e">Information about which key was pressed.</param>
  [JSInvokable]
  public static void JsKeyDown(KeyboardEventArgs e)
  {
    if (e.AltKey && e.Key.ToLower() == "a")
    {
      if (_instance != null)
      {
        _instance.AddCategory();
      }
    }

    if (e.AltKey && e.Key.ToLower() == "s")
    {
      if (_instance != null)
      {
        _instance.OnValidSubmit();
      }
    }
  }

  private void AddCategory()
  {
    // Drop focus from any input to avoid issues with MudBlazor components.
    foreach (var cat in _model.Categories)
    {
      if (cat.Ref is not null)
      {
        cat.Ref.CloseMenuAsync();
      }
    }

    var newCategory = new CategoryAmount();
    _model.Categories.Add(newCategory);
    InvokeAsync(StateHasChanged);

    if (_model.Categories.Count >= 2)
    {
      decimal sum = _model.Categories.Sum(c => c.Amount);
      decimal diff = _model.TotalAmount - sum;

      if (diff < 0)
      {
        diff = 0;
      }
      newCategory.Amount = diff;
    }

    // First, render element to the DOM so that Ref is not null.
    // Then, focus the newly added category input.
    if (newCategory.Ref is not null)
    {
      newCategory.Ref.FocusAsync();
    }
  }

  private void RemoveCategory(CategoryAmount category)
  {
    if (_model.Categories.Count > 1 && category != null)
    {
      _model.Categories.Remove(category);
      StateHasChanged();
    }
  }

  private async Task<IEnumerable<string>> SearchRecievers(
    string phrase,
    CancellationToken token)
  {
    if (string.IsNullOrEmpty(phrase))
    {
      return _recievers;
    }

    IEnumerable<string> result = _recievers
    .Where(x => x.StartsWith(phrase, StringComparison.OrdinalIgnoreCase));

    return result;
  }

  /// <summary>
  /// Update total amount and adjust the first category amount if there is only one category.
  /// </summary>
  /// <param name="value">New value of TotalAmount</param>
  private void UpdateTotalAmount(decimal value)
  {
    _model.TotalAmount = value;

    if (_model.Categories.Count == 1)
    {
      _model.Categories.ElementAt(0).Amount = value;
    }
  }

  /// <summary>
  /// Export all saved transactions into QIF format.
  /// </summary>
  private async Task ExportToDisc()
  {
    var builder = new QifBuilder();
    foreach (var payment in _payments)
    {
      builder = builder.AddTransaction(payment);
    }

    string qifContent = builder.Build();
    byte[] bytes = System.Text.Encoding.UTF8.GetBytes(qifContent);
    var s = new MemoryStream(bytes);

    var fileName = $"transactions-{DateTime.Now:yyyyMMddHHmmss}.qif";
    using var streamRef = new DotNetStreamReference(stream: s);
    await JSRuntime.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
  }
}