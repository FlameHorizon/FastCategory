@page "/"
@rendermode InteractiveServer

@using Core
@using System.Runtime.CompilerServices
@using System.Runtime.InteropServices
@using System.Threading.Tasks
@using System.Globalization
@using System.Diagnostics.CodeAnalysis
@using System.Text
@using Website.Models
@using MudBlazor.Extensions
@using System.ComponentModel.DataAnnotations

@* 
  @@BUG: There is a bug in the application which prevents adding new split categories
  or saving them using keyboard shortcuts when more than one tab open in the browser
  with the application.

  Copilot suggests that the issue might be related to the static _instance field.
  I have tried to remove the static keyword, but then the JSInvokable method can't
  access the instance.

  Personally, I don't know what might be the issue here. Have not seen this before.

  To reproduce the issue:
  1. Start the application.
  2. First tab will open automatically.
  3. Press bunch of times Alt + A to add new split categories.
  4. Open new tab with the application.
  5. In the new tab, try to add new split categories using Alt + A. It will work as well.
  6. Go back to the first tab and try to add new split categories using Alt + A.
     It will not work anymore.
*@

@inject IJSRuntime JSRuntime
@inject Microsoft.Extensions.Options.IOptions<AppSettings> AppSettingsOptions

<PageTitle>Home</PageTitle>

@* TODO: Think about have I can make this button a bit nicer. Although it is not ugly right now. *@
<MudFileUpload T="IBrowserFile" FilesChanged="UploadBankStatement">
    <ActivatorContent>
        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   StartIcon="@Icons.Material.Filled.CloudUpload">
            Upload bank statement
        </MudButton>
    </ActivatorContent>
</MudFileUpload>

<div class="d-flex gap-4">
  <MudItem xs="12" sm="6" md="6">
    <MudPaper Class="pa-4">
      <EditForm Model="@_model" OnValidSubmit="OnValidSubmit">
        <DataAnnotationsValidator/>

        <MudDatePicker 
          Label="Date" 
          @bind-Date="_model.Date" 
          For="@(() => _model.Date)"
          @onkeydown="OnKeyDownDate"
          DateFormat="yyyy-MM-dd"
          ShowToolbar="false"
          autofocus/>

        <MudSelect 
          @bind-Value="_model.TransactionType" 
          Label="Transaction type" >
          @foreach (var opt in _transactionTypes)
          {
            <MudSelectItem Value="opt">@opt</MudSelectItem>
          }
        </MudSelect>

        @* 
           When the user types something that is not on the list and CoerceValue is true, 
           the Value will be overwritten with the user input which allows it to be 
           passed to the validation function.
         *@

        <MudAutocomplete
          @bind-Value="_model.Payee"
          @ref="_payeeRef"
          Label="Payee"
          CoerceValue="true"
          SearchFunc="SearchRecievers">
        </MudAutocomplete>

        <MudNumericField
          T="decimal"
          Format="C"
          Culture="_culture"
          @ref="_totalAmountRef"
          ValueChanged="@(v => UpdateTotalAmount(v))"
          Label="Amount" />

        <div>
          @foreach (var category in _model.Categories)
          {
            <div class="d-flex">
              @*
                CoerceValue is needed to allow user to enter new categories.
              *@
              <MudAutocomplete
                @bind-Value="category.Name"
                Label="Category"
                CoerceValue="true"
                SearchFunc="SearchCategory"
                @ref="category.Ref" />

              <MudNumericField
                @bind-Value="category.Amount"
                Format="C"
                Culture="_culture"
                Immediate="true"
                Label="Split amount" />

              <MudIconButton 
                Icon="@Icons.Material.Filled.Delete" 
                Color="Color.Primary" 
                OnClick="@(() => RemoveCategory(category))" />
            </div>
          }

          <MudButton 
            class="mt-2"
            Variant="Variant.Outlined" 
            Color="Color.Primary" 
            OnClick="AddCategory">
              <MudIcon Icon="@Icons.Material.Filled.Add" />
              Split
          </MudButton>

          <MudTextField 
            @bind-Value="_model.Notes" 
            Label="Notes" 
            Variant="Variant.Outlined" 
            Adornment="Adornment.Start" 
            AdornmentColor="Color.Info"/>

        </div>

        <div class="d-flex flex-row-reverse">
          <MudButton 
            ButtonType="ButtonType.Submit"
            Variant="Variant.Filled"
            Color="Color.Primary"
            Class="ml-auto">
            Save
          </MudButton>
        </div>
      </EditForm>

      <div class="d-flex flex-row-reverse mt-2">
          <MudButton 
            Variant="Variant.Outlined" 
            Color="Color.Primary" 
            OnClick="@(() => ExportToDisc())">
              <MudIcon Icon="@Icons.Material.Filled.Download" />
              Export
          </MudButton>
      </div>


    </MudPaper>
  </MudItem>

  <MudItem xs="12" sm="6" md="6">
    <MudPaper Class="pa-4">
      <h3>Payments</h3>
      <p>List of payments will be shown here.</p>

      @foreach(var p in _payments)
      {
        <div class="mb-2 pa-2" style="border: 1px solid lightgray; border-radius: 8px;">
          <div><b>Date:</b> @p.Date.ToString("yyyy-MM-dd")</div>
          <div><b>Type:</b> @p.TransactionType</div>
          <div><b>Payee:</b> @p.Payee</div>
          <div><b>Total Amount:</b> @p.TotalAmount.ToString("C", CultureInfo.CreateSpecificCulture("pl"))</div>
        </div>
      }
    </MudPaper>
  </MudItem>
</div>



<MudThemeProvider @ref="_mudThemeProvider" @bind-IsDarkMode="_isDarkMode"/>
<MudPopoverProvider />

<script>
  window.downloadFileFromStream = async (fileName, contentStreamReference) => {
    const arrayBuffer = await contentStreamReference.arrayBuffer();
    const blob = new Blob([arrayBuffer]);
    const url = URL.createObjectURL(blob);
    const anchorElement = document.createElement('a');
    anchorElement.href = url;
    anchorElement.download = fileName ?? '';
    anchorElement.click();
    anchorElement.remove();
    URL.revokeObjectURL(url);
  }
</script>

@code {
  // Page related fields.
  private MudAutocomplete<string>? _payeeRef;
  private MudNumericField<decimal>? _totalAmountRef;

  // Control dark mode based on system preference.
  private bool _isDarkMode = true;
  private MudThemeProvider? _mudThemeProvider;

  private CultureInfo _culture = CultureInfo.CreateSpecificCulture("pl");

  // Model for the form.
  private TransactionForm _model = new()
  {
    Categories = [new CategoryAmount() { Name = "", Amount = 0 }]
  };

  // In-memory storage for payments.
  // These payments might be used to export to a file later.
  private readonly List<Payment> _payments = new();

  private IEnumerable<string> _transactionTypes = [
    "Deposit",
    "Withdrawl",
    "Transfer"
  ];
  
  private string[] _searchSpaceCategory = [];
  private string[] _searchSpaceRecievers = [];
  private Queue<BankTransaction> _bankTransactions = [];
  private CategorySearchEngine _categorySearchEngine;

  private static Home? _instance;

#pragma warning disable CS8618
// Non-nullable field '_categorySearchEngine' must contain a non-null value when exiting constructor. 
// Consider adding the 'required' modifier or declaring the field as nullable.
// Justification: _categorySearchEngine is initialized in OnInitialized method.
  public Home()
  {
    _instance = this;
  }

#pragma warning restore CS8618

  protected override void OnInitialized()
  {
    _searchSpaceCategory = AppSettingsOptions.Value.TransactionCategories.ToArray();
    _searchSpaceRecievers = AppSettingsOptions.Value.Recievers.ToArray();
    _categorySearchEngine = new CategorySearchEngine(_searchSpaceCategory);
    Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
  }

  protected async override Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      if (_mudThemeProvider is not null)
      {
        _isDarkMode = await _mudThemeProvider.GetSystemDarkModeAsync();
      }

      await JSRuntime.InvokeVoidAsync("JsFunctions.addKeyboardListenerEvent");
      StateHasChanged();
    }
  }

  private async Task<IEnumerable<string>> SearchCategory(
    string phrase,
    CancellationToken token)
  {
    if (string.IsNullOrEmpty(phrase))
    {
      return _searchSpaceCategory;
    }

    IEnumerable<string> result = _categorySearchEngine.Search(phrase, StringComparison.OrdinalIgnoreCase);
    return await Task.FromResult(result);
  }

  /// <summary>
  /// Handle key presses when the date input is focused.
  /// </summary>
  /// <param name="args">Information about which key was pressed.</param>
  private void OnKeyDownDate(KeyboardEventArgs args)
  {
    if (_model.Date == null)
    {
      _model.Date = DateTime.Today;
      return;
    }

    if (args.CtrlKey)
    {
      return;
    }

    if (args.Key == "=")
    {
      _model.Date = _model.Date.Value.AddDays(1);
    }
    else if (args.Key == "-")
    {
      _model.Date = _model.Date.Value.AddDays(-1);
    }
  }

  private async Task OnValidSubmit()
  {
    // @@NOTE: Right now, I'm assuming the form is always valid.
    // In a real application, you would check the validation state.
    var transactionType = _model.TransactionType switch
    {
      "Deposit" => MMEXTransactionTypes.Deposit,
      "Withdrawl" => MMEXTransactionTypes.Widthdrawl,
      "Transfer" => MMEXTransactionTypes.Transfer,
      _ => MMEXTransactionTypes.Unknown
    };

    var categories = new List<Category>();
    foreach (var cat in _model.Categories)
    {
      string[] split = cat.Name.Split(":");
      string name = split.First();
      string subcategory = split.Last();
      decimal amount = cat.Amount;

      categories.Add(new Category(name, subcategory, amount));
    }

    // @@TODO: Implement following things.
    // ~ 1. Validate that sum of category amounts equals total amount.
    // 2. Validate that at least one category is provided.
    // 3. Validate that date is not null.
    // 4. Validate that transaction type is valid.
    // 5. Validate that payee is not empty.
    // 6. Show validation errors to the user.
    // + 7. Clear the form after successful submission.
    // 8. Allow users to add notes to the transaction.
    // + 9. Since all transactions will be stored in memory, implement second section where they will be displayed.

    // Convert TransactionModel to Payment entity.
    var result = new Payment
    (
      date: _model.Date!.Value,
      transactionType: transactionType,
      totalAmount: _model.TotalAmount,
      payee: _model.Payee,
      categories: categories,
      notes: ""
    );

    _payments.Add(result);

    Console.WriteLine("Form is valid");

    // Setup model for the new transaction.
    _model.Payee = "";

    // @@BUG: It is really hard to clear category name when Alt+S is pressed.
    // I've noticed that most of the problems stems from JsKeyDown method.
    // Everything works just fine when I press buttons on webpage instead
    // of using keyboard shortcuts.

    // @@BUG: For some reason, why I use keypress (Alt+S) to save
    // transaction, payee and category value is not refreshed after StateHasChanged.
    // I'm doing this manually then.
    if (_payeeRef is not null)
    {
#pragma warning disable BL0005
// Component parameter should not be set outside of its component
// Justification: When saving transaction via Alt+S value of last payee is not rendered.
      _payeeRef.Value = "";
#pragma warning restore BL0005

      await InvokeAsync(_payeeRef.ForceUpdate);
    }

    _model.Categories.Clear();
    _model.Categories.Add(new CategoryAmount());

    await PrefillFormWithNextTransaction();
    await InvokeAsync(StateHasChanged);
  }

  /// <summary>
  /// Handle key presses from JavaScript.
  /// </summary>
  /// <param name="e">Information about which key was pressed.</param>
  [JSInvokable]
  public static async Task JsKeyDown(KeyboardEventArgs e)
  {
    if (e.AltKey && e.Key.ToLower() == "a")
    {
      if (_instance != null)
      {
        _instance.AddCategory();
      }
    }

    if (e.AltKey && e.Key.ToLower() == "s")
    {
      if (_instance != null)
      {
        await _instance.OnValidSubmit();
      }
    }
  }

  /// <summary>
  /// Adds a new row with category name and amount assigned to it for user entry.
  /// If there is unallocated sum of money, new category will auto-fill with 
  /// the difference.
  /// </summary>
  private void AddCategory()
  {
    // Drop focus from any input to avoid issues with MudBlazor components.
    foreach (var cat in _model.Categories)
    {
      if (cat.Ref is not null)
      {
        cat.Ref.CloseMenuAsync();
      }
    }

    var newCategory = new CategoryAmount();
    _model.Categories.Add(newCategory);

    if (_model.Categories.Count >= 2)
    {
      decimal sum = _model.Categories.Sum(c => c.Amount);
      decimal diff = _model.TotalAmount - sum;

      if (diff < 0)
      {
        diff = 0;
      }
      newCategory.Amount = diff;
    }

    // First, render element to the DOM so that Ref is not null.
    // Then, focus the newly added category input.
    if (newCategory.Ref is not null)
    {
      newCategory.Ref.FocusAsync();
    }
    InvokeAsync(StateHasChanged);
  }

  private void RemoveCategory(CategoryAmount category)
  {
    if (_model.Categories.Count > 1 && category != null)
    {
      _model.Categories.Remove(category);
      StateHasChanged();
    }
  }

  private async Task<IEnumerable<string>> SearchRecievers(
    string phrase,
    CancellationToken token)
  {
    if (string.IsNullOrEmpty(phrase))
    {
      return _searchSpaceRecievers;
    }

    IEnumerable<string> result = _searchSpaceRecievers
      .Where(x => x.StartsWith(phrase, StringComparison.OrdinalIgnoreCase));

    return await Task.FromResult(result);
  }

  /// <summary>
  /// Update total amount and adjust the first category amount if there is only one category.
  /// </summary>
  /// <param name="value">New value of TotalAmount</param>
  private void UpdateTotalAmount(decimal value)
  {
    _model.TotalAmount = value;

    if (_model.Categories.Count == 1)
    {
      _model.Categories.ElementAt(0).Amount = value;
    }
  }

  /// <summary>
  /// Export all saved transactions into QIF format.
  /// </summary>
  private async Task ExportToDisc()
  {
    var builder = new QifBuilder();
    foreach (var payment in _payments)
    {
      builder = builder.AddTransaction(payment);
    }

    string qifContent = builder.Build();
    byte[] bytes = System.Text.Encoding.UTF8.GetBytes(qifContent);
    var s = new MemoryStream(bytes);

    var fileName = $"transactions-{DateTime.Now:yyyyMMddHHmmss}.qif";
    using var streamRef = new DotNetStreamReference(stream: s);
    await JSRuntime.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
  }

  private async Task UploadBankStatement(IBrowserFile file)
  {
    // @@TODO: Allow user (for now) only to upload csv files.

    // @@NOTE: Uploading bank statement for the second time
    // will override previous value.

    // Since I know that my statement will contains Polish symbols like ą, ć, ę, ł and others
    // correct codepage has to be loaded.
    using StreamReader sr = new StreamReader(file.OpenReadStream(), Encoding.GetEncoding(1250));
    string content = await sr.ReadToEndAsync();
    string[] allLines = content.Split(Environment.NewLine, StringSplitOptions.None);

    // Transactions will be displayed in order of the oldest to newest.
    // This is how I typically fill my budget.
    IEnumerable<BankTransaction> transactions = BankStatementParser.Parse(allLines, skipHeader: true)
    .OrderBy(x => x.CurrencyDate);

    _bankTransactions = new Queue<BankTransaction>(transactions);

    await PrefillFormWithNextTransaction();
  }

  private async Task PrefillFormWithNextTransaction()
  {
    if (_bankTransactions != null && _bankTransactions.Count > 0)
    {
      var next = _bankTransactions.Dequeue();
      _model.Date = next.CurrencyDate;

      // @@NOTE: Using absolute values here since TransactionType
      // will determine if money should be added to bank account
      // or substracted from it.
      _model.TotalAmount = Math.Abs(next.Amount);

      // @@HACK: Since total amount component is not bound to a
      // value directly using @bind-Value, I need to update it
      // manually and force to render manually.
      // Without these two lines below, component will not have
      // value displayed.
      if (_totalAmountRef is not null)
      {
#pragma warning disable BL0005
// Component parameter should not be set outside of its component
// Justification: When saving transaction via Alt+S value of last payee is not rendered.
        _totalAmountRef.Value = Math.Abs(next.Amount);
#pragma warning restore BL0005
        _totalAmountRef.ForceRender(true);
      }

      // This method call updates total amount (which is already set manually)
      // and amount for the first category.
      UpdateTotalAmount(_model.TotalAmount);

      // @@TODO: Add more information for each transaction.
      var sb = new StringBuilder();
      if (next.TransactionType == BankTransactionType.CardPayment)
      {
        sb.AppendLine($"Adres: {next.GetAddress()}");
      }

      _model.Notes = sb.ToString();

      // Since date and transaction type are already filled, focus on Payee field.
      // I'm focusing and closing menu to put just cursor on the field.
      // I don't need to see suggestions immiedietly.
      if (_payeeRef is not null)
      {
        await _payeeRef.FocusAsync();
        await _payeeRef.CloseMenuAsync();
      }
    }
  }
}